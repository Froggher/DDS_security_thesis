\chapter{Introduzione al DDS}
In questo capitolo viene fatta un'introduzione generale dello 
standard del Data Distribution Service (DDS) gestita
dall'Object Management Group (OMG). Inizialmente a livello generale 
per poi andare sempre più nel
dettaglio per capire il suo funzionamento, che ci sarà utile 
capire per comprendere le vulnerabilità che verranno analizzate in
successivi capitoli. Inoltre verrà introdotta la sua estensione
DDS security che si occupa di rendere più sicuro lo standard DDS 
aggiungendo elementi di sicurezza come l'autenticazione e una 
implementazione della cifratura dei pacchetti scambiati tra i vari
dispositivi connessi alla rete. Successivamente verranno mostrate delle 
implementazioni e in quali contesti viene utilizzato utilizzato
attualmente e in futuro. 
Infine verra mostrato in quali contesti attuali e futuri viene
utilizzato con le sue diverse implementazioni.

In questa tesi, in dei casi, verrà omessa la specifica OMG perchè 
ci riferiremo
esclusivamente al DDS conforme all'Object Management Group. Questo 
standard ha delle specifiche tecniche ben precise, consente
l'interoperabilità tra i diversi vendor che lo rispettano, insieme
a tanti altri numerosi vantaggi.
\cite{dds1.4}


\section{Modello publish/subscribe}
Prima di paralare del DDS, é necessario prima capire il 
funzionamento del modello Publish-Subscribe 
che sta alla base di tutto il suo funzionamento.
Questo sistema di publish e subscribe non funziona come la 
classica applicazione che siamo abituati a vedere tra server e
client tramite protocollo TCP/IP nell'ambito delle comunicazioni. 


\subsection{Perché non usiamo una connessione con TCP/IP}
Prendiamo l'esempio di un collegamento tra una workstation e 
un sensore per la temperatura. La connessione a livello fisico
avverrá tramite un collegamento Ethernet. La workstation e il 
sensore quindi si trovano nello stesso network e possono 
ora cominciare a comunicare tra di loro. L'obiettivo é quello
di trasferire i dati dal sensore alla workstation in modo tale
da poterli visualizzare a schermo.
Il metodologia piú frequente é quella di utilizzare un socket tramite 
protocollo TCP/IP, ma non sempre é la soluzione migliore.
Dei vantaggi del TCP/IP sono la disponibilitá di utilizzo 
in molte situazioni e nella maggior parte delle connessioni a 
Internet viene utilizzato questo protocollo.
Tuttavia, in certe situazioni, TCP/IP non risulta la soluzione migliore,
specialmente quando dobbiamo collegare un numero di dispositivi al 
network che puó cambiare. Se nel nostro network tra workstation e 
sensore della temperatura, aggiungiamo un'altro dispositivo, come un 
sensore per la temperatura, bisogna creare un nuovo socket 
TCP/IP per far comunicare il nuovo senore con la workstation.
Questo succede perchè TCP/IP supportá una comunicazione di tipo 
one-to-one (uno a uno). Come vedremó nella prossima sottosezione,
il modello publish/subscribe non ha questa limitazione \cite{1494965}.

\subsection{Struttura modello publish/subscribe}
% Citazione da mettere
Per funzionare il modello publish/subscribe ha bisogno di
elementi che sono necessari per il sistema di scambio delle 
comunicazioni. 
Questi elementi, che rappresentano i componenti all'interno
del modello publish/subscribe, vengono chiamati chiamati entità.
Il publisher e il Subscriber sono le entità principali
che possono comunicare tra di loro quando hanno un topic, che
rappresenta una tipologia di dati, (ad esempio temperatura, 
distanza, velocitá, etc...) in comune tra di loro.
\begin{itemize}
    \item Publisher: colui che "pubblica" nuovi dati riguardanti dei
    topic rendendoli accessibili ai subscriber iscritti. 
    Di solito si tratta di un sensore.
    \item Subscriber: colui che si "iscrive" ai topic del publisher, 
    cominciando
    cosí a ricevere nuovi dati sul topic scelto. Molte volte si tratta
    di un dispositivo utilizzato per mostrare informazioni, come un
    semplice schermo.
\end{itemize}
Una caratteristica di queste entitá é che possono essere aggiunte o rimosse
senza nessun problema, sia publisher che subscriber, dato che le 
comunicazioni avvengono in modalitá asincrona. Un publisher come impostazione
predefinita non deve ricevere conferma di ricezione da parte del 
subscriber a cui manda i pacchetti contenenti i dati riguardo il topic.
In questo modo il publisher puó continuamente mandare nuovi dati
senza effettuare operazioni di conferma, rendendendo cosí le comunicazioni
molto piú responsive \cite{dds1.4}. 

Un'altra qualitá del modello
publish/subscribe si manifesta quando
un publisher deve inviare dei nuovi dati a piú subscriber. 
In tale situazione, un
modello multicast viene utilizzato per i mandare i pacchetti, che vengono 
poi ricevuti da un'entitá che si occuperá di mandare ai subscriber
le nuove informazioni riguardanti i topic a cui sono iscritti.
Il modello cosí risulta molto
flessibile e utilizzabile in ambienti real-time dove le fonti delle
comunicazioni possono cambiare o essere utilizzate da piú dispostivi,
ad esempio i subscriber possono avere cambiare i topic a cui 
sono iscritti e/o i publisher possono smettere di pubblicare nuove
informazioni su un determinato topic \cite{OH2010318}.

\section{Che cos'é il Data Distribution Service}

Il DDS gestito da OMG è un middleware e uno standard API per una gestione
dei dati di tipo data-centric. Questo middleware è un software che si trova
tra l'applicativo e il sistema operativo. Viene utilizzato un modello
di tipo publish/subscribe, ma con un approccio più data-centric, in modo
tale da semplificare il lavoro del programmatore che si deve solamente
occupare di specificare il contesto del dato che deve mandare o ricevere.
Così facendo non bisogna preoccuparsi dell'invio o della ricezione
dei messaggi, perchè questa parte viene completamente gestita dal middleware.
Prima di questo middleware esistevano solamente soluzioni proprietarie che si 
basavano sempre sul modello publish/subscribe. Il DDS é stato il primo standard
a formalizzare le comunicazioni di tipo data-centric. Inizialmente erano 
disponibili solamente soluzioni proprietarie senza specificare un standard
univoco. Non avendo avuto uno standard univoco le varie implementazioni non sono
compatibili tra di loro a differenza del DDS che lo é.

Altri vantaggi del DDS includono una architettura adattabile dato che supportá
degli elementi di auto-scoperta (auto-discovery) in modo tale da aggiungere o 
rimuovere dispositivi dalla rete in automatico. Rispetto al protocollo TCP/IP 
il DDS ha la possibilitá di effettuare comunicazioni di tipo uno a molti 
(one-to-many), molti a molti (many-to-many) e uno a uno (one-to-one)
 \cite{1494965}.

\subsection{Global Space Data}
Il DDS a livello concettuale utilizza un concetto chiamato Global Data 
Space (spazio dati globale) che consente agli applicativi
di accedere a una sorta di memoria locale tramite API.
L'applicativo nella scrittura o nella ricezione dei dati utilizzerá 
questa memoria locale fittizia come un'unica risorsa centralizzata.
In realtá, i dati all'interno di questa memoria possono contenere
informazioni provenienti da nodi remoti distribuiti per la rete. 
L'applicativo non deve cosi preoccupandosi dell'accessibilitá dei dati,
dato che vengono gestiti dal DDS.\cite{whatisdds}


\subsection{Quality of Service (QoS)}

Per soddisfare i diversi requisiti di una trasmissione dati, 
il Data Distribution Service (DDS) utilizza un insieme di policy di 
Quality of Service (QoS). Queste policy permettono di controllare, 
regolare e ottimizzare lo scambio di dati tra i vari componenti 
all'interno del middleware. Le policy QoS possono variare 
significativamente in base al tipo di comunicazione richiesta, 
offrendo una gestione altamente flessibile e granulare. 
Ogni elemento del middleware può essere configurato 
con policy specifiche, consentendo un adattamento preciso alle 
esigenze dell'applicazione.

\subsection{Dynamic Discovery}


\subsection{Modularitá ed estensioni}
Ad esempio DDS security

% \subsection{In che contesti viene utilizzato e perché}

% \subsection{Versioni DDS}



% Schema layer middleware

% https://www.dds-foundation.org/what-is-dds-3/

\section{Le entitá del DDS}
Il DDS per operare utilizza le entitá, che rappresentano gli elementi necessari
per il funzionamento del middleware. Hanno il compito di gestire i dati
scambiati tra i vari partecipanti all'interno del sistema. 
Le entitá principali del DDS sono: 
il publisher, il subscriber, il DataWriter, il DataReader, il Topic,
la Istanza, il Domain e il Domain Participant.
Ognuna di queste identitá deve tener conto del set suo di policies QoS configurate
che ne definiscono il comportamento. Queste policy verranno analizzate 
nel piú nel dettaglio in una prossima sezione.

Il linguaggio utilizzato da queste entitá si chiama Interface 
Definition Language(IDL),
viene gestito anch'esso da OMG. Molto simile a un linguaggio tipizzato 
simile a C++, supportá data types come char, int, double, float etc
\cite{1494965} \dots


\subsection{Publisher e Subscriber}

Qualche entitá l'abbiamo già incontrata
in precedenza nel modello publish/subscribe, in particolare, il publisher e 
il subscriber che mantengono immutato il loro ruolo all'interno del DDS.

\subsection{DataWriter e DataReader}

Per comunicare tra loro, il publisher si interfaccia tramite
DataWriter, 
mentre il subscriber si interfaccia tramite DataReader.
Il DataWriter e il DataReader si definiscono come interfacce, 
poiché l'applicativo
può mandare e/o ricevere dati all'interno del middleware
tramite queste due entitá fondamentali. 
Questi dati scambiati tra middleware e applicativo durante la spedizione e/o 
ricezione sono i data type e i data-object. I data type consentono di 
descrivere la struttura e il formato del dato, mentre i data-object
sono i dati veri e propri dato che rispettano le specifiche data type.
\begin{itemize}
    \item DataWriter: é l'interfaccia usata dagli applicativi 
    per comunicare i
    data-objects con un loro specifico data type ai publisher.
    Ricevuti questi data-objects il publisher potrá mandare le
    informazioni ricevute dall'applicativo ai relativi subscriber.
    \item DataReader: é l'interfaccia usata dagli applicativi per
    ricevere i data-objects con i loro data type pubblicati in
    precedenza da un publisher.
\end{itemize}\cite{dds1.4}
Inoltre c'è la possibilità di avere 
più DataWriter associati a un publisher e più DataReader associati a 
un Subscriber. Tuttavia, un DataWriter o un DataReader possono essere 
associati solamente ad un solo topic.
Ad esempio avendo i topic: velocitá e temperatura, dobbiamo utilizzare
due DataWriter e due DataWriter per effettuare una comunicazione tra
publisher e subscriber dato che possono gestire un solo data type per volta.


\subsection{Topic}
Nel modello publish/subscribe abbiamo giá introdotto i topic, ma 
abbiamo la necessitá di approfondirli quando vengono utilizzati
con le specifiche del DDS.

I topic vengono utilizzati per identificare il tipo di dato che viene
scambiato tra i publishers e i subscribers, creando cosi un punto
di connessione 
tra DataWriter e DataWriter\cite{topicomg} .
All'interno troviamo il nome del topic
(che deve essere nel dominio dove si trova),
i data types del topic e le policy QoS relative ai topic.
Il nome del topic deve essere una stringa che serve 
a identificare il topic all'interno di un dominio e quindi deve essere
univoca.




\subsection{Key e Instanza}
Uno o piú data types di un topic possono diventare una chiave (key) per 
quel particolare topic. Queste chiavi ci permettono di suddivedere meglio
i dati per un singolo topic, dividendo i dati che hanno il valore contenuto
nella key diverso. Ogni suddivisione che effettuiamo tramite una key crea 
un'istanza diversa. L'istanza al suo interno contiene i data-values che 
vengono ricevuti da un qualche flusso di data (data-stream).
 \cite{Instance81:online}.

Per fare un esempio prendiamo il topic velocità in un contesto dove si
vogliono analizzare i dati di una gara.
La struttura del topic avrà due elementi: il primo corrisponde al valore
della velocità registrata, mentre il secondo mostra l'id-macchina per 
capire da quale vettura i dati provengono.
\begin{lstlisting}[language=C++, caption=Esempio di Topic con una key
    usando il linguaggio IDL
    , label=Topic struct]
    struct Veicolo { // Nome del topic
        id_macchina; // Key del topic
        velocita;
    }
    \end{lstlisting}
Creiamo ora due istanze una con valore 270 (velocità) e con 
l'id-macchina a 1 e l'altra con un valore di 220 e con id-macchina 
uguale a 2. Notiamo che l'id-macchina in questo caso fungerà da key 
dell'istanza per distinguere la provenienza dei dati, in questo
modo possiamo controllare le due macchine con due istanze ciascuna.

% Magari anche con RTI shapes


    


\subsection{Domain}
L'entitá del dominio rapresenta uno spazio logico definito con
lo scopo di contenere Topics e data-types. 
Le proprietá del domain sono:
\begin{itemize}
    \item Ogni dominio viene identificato da un id per 
    per renderlo univoco.
    \item Ogni entitá del DDS puó appartenere
    a un solo dominio
    \item Le entitá all'interno del dominio possono interagire
    solamente con le altre entitá all'interno dello stesso domain
    \item Due applicativi DDS per poter comunicare tra di loro
    hanno bisogno di entrare in un unico dominio
    \item Un applicativo, creando l'entita DomainParticipant per ogni
    dominio a cui vuole partecipare, puó far parte di piú di un 
    dominio
\end{itemize}\cite{domainrti}

% (possibilitá di aggiungere esempi con demo shapes)

\subsection{DomainParticipant}
L'entitá del DomainParticipant viene utilizzata da un'applicazione
per entrare all'interno di un domain. 
Rappresenta la prima entitá creata da un'applicazione che verrá 
utilizzata per creare altre entitá. Ha il compito di inizializzare
le comunicazioni con il domain attraverso il processo di discovery.
Il processo di discovery consente alle entitá appartenenti allo 
stesso domain di trovarsi e connettere automaticamente.
% Processo discovery non ancora introdotto
Le proprietá del DomainParticipant sono:
\begin{itemize}
    \item Un DomainParticipant puó entrare solamente all'interno
    di un domain.
    \item Il DomainParticipant é responsabile per scoprire altre
    entitá DomainParticipant all'interno del domain (dove entrambe
    si devono trovare)
\end{itemize}\cite{domainparticipantrti}




\section{Modello DDS}
Sto facendo un test di prova riguardante questo testo scritto
tipo lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum
lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum lorem ipsum